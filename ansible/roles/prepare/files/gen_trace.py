#!/usr/bin/env python3

import sys, getopt
import random
from scapy.all import DNS, DNSQR, DNSRR, IP, IPv6, UDP, wrpcap, Ether

dbfile = 'querydb'
target = ['127.0.0.1','127.0.0.1']
target_port = 53
dnssec_ratio = 0.0
ecs_ratio = 0.0
ecs_list = ["\x00\x08\x00\x06\x00\x01\x10\x00\x58\x92",
            "\x00\x08\x00\x06\x00\x01\x10\x00\x08\x52",
            "\x00\x08\x00\x06\x00\x01\x10\x00\xC0\xA8"]
file_suffix = ""
macs=['00:00:00:00:00','00:00:00:00:00']
src_mac = '00:00:00:00:00'

# Usage
def usage():
    print("{:s}: [-h] [-t TARGETS] [-p PORT] [-d DO-PERCENT] [-e ECS-PERCENT] [-s output suffix] [querydb]".format(sys.argv[0]))
    print("Parameters:")
    print("\t-h             Help")
    print("\t-t TARGETS      Target DNS server ({:s}) separated by commas".format(",".join(target)))
    print("\t-p PORT        Target DNS server port ({:d})".format(target_port))
    print("\t-d DO-PERCENT  Percent of packets with DO bit ({:0.1f})".format(dnssec_ratio))
    print("\t-e ECS-PERCENT Percent of packets with random ECS ({:0.1f})".format(ecs_ratio))
    print("\t-s FILE-SUFFIX for the pcap file ({:s})".format(file_suffix))
    print("\t-m Mac addresses    ({:s})".format(",".join(macs)))
    print("\t-a Current Mac Adress as src for ethernet packages ({:s})".format(src_mac))
    print("\t[querydb]      May be generated by gen_queries.sh")
    print("\t                format: 'name QTYPE'")

# Parse options
try:
    opts, args = getopt.getopt(sys.argv[1:], "ht:p:d:e:y:s:m:a:", [])
except getopt.GetoptError as err:
    usage()
    sys.exit(1)
for o, a in opts:
    if o == '-h':
        usage()
        sys.exit(1)
    elif o == '-t':
        target = a.split(",")
    elif o == '-p':
        target_port = int(a)
    elif o == '-d':
        assert(0 <= int(a) and int(a) <= 100)
        dnssec_ratio = int(a) / 100.0
    elif o == '-e':
        assert(0 <= int(a) and int(a) <= 100)
        ecs_ratio = int(a) / 100.0
    elif o == '-s':
        file_suffix = a
    elif o == '-m':
        macs = a.split(",")
    elif o == '-a':
        src_mac = a
    else:
        usage()
        sys.exit(1)

# Arguments
if len(args) >= 1:
    dbfile = args[len(args) - 1] # The last argumetn duh

# Create list of packets
PKTS = []
pcap_out = 'queries-ipv{:s}{:s}.pcap'.format("6" if ':' in target else "4", file_suffix)

# Add query
def add_query(msg, src_port, target, dst_mac):
    if ':' in target:
        PKTS.append(Ether(dst=dst_mac,src=src_mac)/IPv6(dst=target)/UDP(sport=src_port,dport=target_port)/msg)
    else:
        PKTS.append(Ether(dst=dst_mac,src=src_mac)/IP(dst=target)/UDP(sport=src_port,dport=target_port)/msg)

# Read querydb
all_count = 0
dnssec_count = 0
ecs_count = 0
fd = open(dbfile)
modulo = len(target)
for l in fd:
    try:
        l = l.strip().split(' ')
        if len(l) < 2:
            print("There's a faulty line: {}".format(str(l)))
            continue

        # Don't use 0 source port (sendto doesn't like it) and reserved ports
        # (Bind drops these 7, 13, 19, 37 and 464), rfc5452#section-4.5.
        rnd = random.randint(1024, 49152)

        msg=DNS(id=rnd, qdcount=1, qd=DNSQR(qname=l[0], qtype=l[1]))

        # Add optional DO bit.
        if dnssec_ratio == 1 or all_count * dnssec_ratio > dnssec_count:
            msg.arcount = 1
            msg.ar = DNSRR(rrname='.', type=41, rclass=4096, ttl=0x8000)
            dnssec_count += 1

        # Add optional ECS.
        if ecs_ratio == 1 or all_count * ecs_ratio > ecs_count:
            # If EDNS for DNSSEC was not already added, add OPT RR.
            if msg.arcount != 1:
                msg.arcount = 1
                msg.ar = DNSRR(rrname='.', type=41, rclass=4096, ttl=0x0000)
            msg.ar.rdata = random.choice(ecs_list)
            ecs_count += 1

        add_query(msg, rnd, target[all_count%modulo], macs[all_count%modulo])
    except Exception as er:
        print(er)
        print("Case was {}".format(str(l)))
        continue
all_count += 1
fd.close()

# Dump to pcap
if len(PKTS) > 0:
    # Shuffle packets to randomize server responses
    random.shuffle(PKTS)
    wrpcap(pcap_out, PKTS)

print("done")
